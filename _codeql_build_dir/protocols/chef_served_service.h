/**
* This file was generated by the gracht service generator script. Any changes done here will be overwritten.
 */

#ifndef __CHEF_SERVED_SERVICE_H__
#define __CHEF_SERVED_SERVICE_H__

#include <assert.h>
#include <gracht/types.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>


#define SERVICE_CHEF_SERVED_ID 42
#define SERVICE_CHEF_SERVED_FUNCTION_COUNT 6

#define SERVICE_CHEF_SERVED_INSTALL_ID 1
#define SERVICE_CHEF_SERVED_REMOVE_ID 2
#define SERVICE_CHEF_SERVED_INFO_ID 3
#define SERVICE_CHEF_SERVED_LISTCOUNT_ID 4
#define SERVICE_CHEF_SERVED_LIST_ID 5
#define SERVICE_CHEF_SERVED_GET_COMMAND_ID 6

#define SERVICE_CHEF_SERVED_EVENT_PACKAGE_INSTALLED_ID 7
#define SERVICE_CHEF_SERVED_EVENT_PACKAGE_REMOVED_ID 8
#define SERVICE_CHEF_SERVED_EVENT_PACKAGE_UPDATED_ID 9


#ifndef GRMIN
#define GRMIN(a, b) (((a)<(b))?(a):(b))
#endif //! GRMIN

#ifndef __GRACHT_SERVICE_SHARED_SERIALIZERS
#define __GRACHT_SERVICE_SHARED_SERIALIZERS
#define SERIALIZE_VALUE(name, type) static inline void serialize_##name(gracht_buffer_t* buffer, type value) { \
                                        *((type*)&buffer->data[buffer->index]) = value; buffer->index += sizeof(type); \
                                    }

#define DESERIALIZE_VALUE(name, type) static inline type deserialize_##name(gracht_buffer_t* buffer) { \
                                          type value = *((type*)&buffer->data[buffer->index]); \
                                          buffer->index += sizeof(type); \
                                          return value; \
                                       }


SERIALIZE_VALUE(uint8, uint8_t)
DESERIALIZE_VALUE(uint8, uint8_t)
SERIALIZE_VALUE(int8, int8_t)
DESERIALIZE_VALUE(int8, int8_t)
SERIALIZE_VALUE(uint16, uint16_t)
DESERIALIZE_VALUE(uint16, uint16_t)
SERIALIZE_VALUE(int16, int16_t)
DESERIALIZE_VALUE(int16, int16_t)
SERIALIZE_VALUE(uint32, uint32_t)
DESERIALIZE_VALUE(uint32, uint32_t)
SERIALIZE_VALUE(int32, int32_t)
DESERIALIZE_VALUE(int32, int32_t)
SERIALIZE_VALUE(uint64, uint64_t)
DESERIALIZE_VALUE(uint64, uint64_t)
SERIALIZE_VALUE(int64, int64_t)
DESERIALIZE_VALUE(int64, int64_t)
SERIALIZE_VALUE(long, long)
DESERIALIZE_VALUE(long, long)
SERIALIZE_VALUE(ulong, size_t)
DESERIALIZE_VALUE(ulong, size_t)
SERIALIZE_VALUE(uint, unsigned int)
DESERIALIZE_VALUE(uint, unsigned int)
SERIALIZE_VALUE(int, int)
DESERIALIZE_VALUE(int, int)
SERIALIZE_VALUE(bool, uint8_t)
DESERIALIZE_VALUE(bool, uint8_t)
SERIALIZE_VALUE(float, float)
DESERIALIZE_VALUE(float, float)
SERIALIZE_VALUE(double, double)
DESERIALIZE_VALUE(double, double)

static inline void serialize_string(gracht_buffer_t* buffer, const char* string) {
    uint32_t length = string != NULL ? (uint32_t)strlen(string) : 0;
    *((uint32_t*)&buffer->data[buffer->index]) = length;
    if (length == 0) {
        buffer->data[buffer->index + sizeof(uint32_t)] = 0;
        buffer->index += sizeof(uint32_t) + 1;
        return;
    }
    memcpy(&buffer->data[buffer->index + sizeof(uint32_t)], string, length);
    buffer->data[buffer->index + sizeof(uint32_t) + length] = 0;
    buffer->index += (sizeof(uint32_t) + length + 1);
}

static inline void deserialize_string_copy(gracht_buffer_t* buffer, char* out, uint32_t maxLength) {
    uint32_t length = *((uint32_t*)&buffer->data[buffer->index]);
    uint32_t clampedLength = GRMIN(length, maxLength - 1);
    if (clampedLength > 0) {
        memcpy(out, &buffer->data[buffer->index + sizeof(uint32_t)], clampedLength);
    }
    out[clampedLength] = 0;
    buffer->index += sizeof(uint32_t) + length + 1;
}

static inline char* deserialize_string_nocopy(gracht_buffer_t* buffer) {
    uint32_t length = *((uint32_t*)&buffer->data[buffer->index]);
    char*    string = &buffer->data[buffer->index + sizeof(uint32_t)];
    buffer->index += sizeof(uint32_t) + length + 1;
    return string;
}
#endif //! __GRACHT_SERVICE_SHARED_SERIALIZERS


struct chef_served_command;
static void serialize_chef_served_command(gracht_buffer_t* buffer, const struct chef_served_command* in);
static void deserialize_chef_served_command(gracht_buffer_t* buffer, struct chef_served_command* out);

struct chef_served_package;
static void serialize_chef_served_package(gracht_buffer_t* buffer, const struct chef_served_package* in);
static void deserialize_chef_served_package(gracht_buffer_t* buffer, struct chef_served_package* out);


#ifndef __CHEF_INSTALL_STATUS_DEFINED__
#define __CHEF_INSTALL_STATUS_DEFINED__
enum chef_install_status {
    CHEF_INSTALL_STATUS_SUCCESS,
    CHEF_INSTALL_STATUS_FAILED_VERIFICATION,
    CHEF_INSTALL_STATUS_FAILED_INSTALL,
    CHEF_INSTALL_STATUS_FAILED_LOAD,
    CHEF_INSTALL_STATUS_FAILED_HOOKS,
};
#endif //! __CHEF_INSTALL_STATUS_DEFINED__

#ifndef __CHEF_UPDATE_STATUS_DEFINED__
#define __CHEF_UPDATE_STATUS_DEFINED__
enum chef_update_status {
    CHEF_UPDATE_STATUS_SUCCESS,
    CHEF_UPDATE_STATUS_FAILED_UNLOAD,
    CHEF_UPDATE_STATUS_FAILED_INSTALL,
    CHEF_UPDATE_STATUS_FAILED_LOAD,
    CHEF_UPDATE_STATUS_FAILED_HOOKS,
};
#endif //! __CHEF_UPDATE_STATUS_DEFINED__


#ifndef __CHEF_SERVED_COMMAND_DEFINED__
#define __CHEF_SERVED_COMMAND_DEFINED__
struct chef_served_command {
    int type;
    char* path;
    char* arguments;
    char* data_path;
    char* container_control_path;
};


static void chef_served_command_init(struct chef_served_command* in) {
    memset(in, 0, sizeof(struct chef_served_command));
}

static void chef_served_command_copy(const struct chef_served_command* in, struct chef_served_command* out) {
    out->type = in->type;
    if (in->path != NULL) {
        out->path = strdup(in->path);
    } else {
        out->path = NULL;
    }
    if (in->arguments != NULL) {
        out->arguments = strdup(in->arguments);
    } else {
        out->arguments = NULL;
    }
    if (in->data_path != NULL) {
        out->data_path = strdup(in->data_path);
    } else {
        out->data_path = NULL;
    }
    if (in->container_control_path != NULL) {
        out->container_control_path = strdup(in->container_control_path);
    } else {
        out->container_control_path = NULL;
    }
}

static void chef_served_command_destroy(struct chef_served_command* in) {
    if (in->path) {
        free(in->path);
    }
    if (in->arguments) {
        free(in->arguments);
    }
    if (in->data_path) {
        free(in->data_path);
    }
    if (in->container_control_path) {
        free(in->container_control_path);
    }
}

#endif //! __CHEF_SERVED_COMMAND_DEFINED__

#ifndef __CHEF_SERVED_PACKAGE_DEFINED__
#define __CHEF_SERVED_PACKAGE_DEFINED__
struct chef_served_package {
    char* name;
    char* version;
};


static void chef_served_package_init(struct chef_served_package* in) {
    memset(in, 0, sizeof(struct chef_served_package));
}

static void chef_served_package_copy(const struct chef_served_package* in, struct chef_served_package* out) {
    if (in->name != NULL) {
        out->name = strdup(in->name);
    } else {
        out->name = NULL;
    }
    if (in->version != NULL) {
        out->version = strdup(in->version);
    } else {
        out->version = NULL;
    }
}

static void chef_served_package_destroy(struct chef_served_package* in) {
    if (in->name) {
        free(in->name);
    }
    if (in->version) {
        free(in->version);
    }
}

#endif //! __CHEF_SERVED_PACKAGE_DEFINED__

#ifndef __GRACHT_CHEF_SERVED_COMMAND_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_SERVED_COMMAND_SERIALIZER_DEFINED__
static void serialize_chef_served_command(gracht_buffer_t* buffer, const struct chef_served_command* in) {
    serialize_int(buffer, in->type);
    serialize_string(buffer, in->path);
    serialize_string(buffer, in->arguments);
    serialize_string(buffer, in->data_path);
    serialize_string(buffer, in->container_control_path);
}

static void deserialize_chef_served_command(gracht_buffer_t* buffer, struct chef_served_command* out) {
    out->type = deserialize_int(buffer);
    uint32_t _path_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->path = malloc(_path_length + 1);
    assert(out->path != NULL);
    deserialize_string_copy(buffer, &out->path[0], 0);
    uint32_t _arguments_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->arguments = malloc(_arguments_length + 1);
    assert(out->arguments != NULL);
    deserialize_string_copy(buffer, &out->arguments[0], 0);
    uint32_t _data_path_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->data_path = malloc(_data_path_length + 1);
    assert(out->data_path != NULL);
    deserialize_string_copy(buffer, &out->data_path[0], 0);
    uint32_t _container_control_path_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->container_control_path = malloc(_container_control_path_length + 1);
    assert(out->container_control_path != NULL);
    deserialize_string_copy(buffer, &out->container_control_path[0], 0);
}
#endif //! __GRACHT_CHEF_SERVED_COMMAND_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_SERVED_PACKAGE_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_SERVED_PACKAGE_SERIALIZER_DEFINED__
static void serialize_chef_served_package(gracht_buffer_t* buffer, const struct chef_served_package* in) {
    serialize_string(buffer, in->name);
    serialize_string(buffer, in->version);
}

static void deserialize_chef_served_package(gracht_buffer_t* buffer, struct chef_served_package* out) {
    uint32_t _name_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->name = malloc(_name_length + 1);
    assert(out->name != NULL);
    deserialize_string_copy(buffer, &out->name[0], 0);
    uint32_t _version_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->version = malloc(_version_length + 1);
    assert(out->version != NULL);
    deserialize_string_copy(buffer, &out->version[0], 0);
}
#endif //! __GRACHT_CHEF_SERVED_PACKAGE_SERIALIZER_DEFINED__

#endif //! __CHEF_SERVED_SERVICE_H__
