/**
* This file was generated by the gracht service generator script. Any changes done here will be overwritten.
 */

#ifndef __CHEF_SERVED_SERVICE_H__
#define __CHEF_SERVED_SERVICE_H__

#include <assert.h>
#include <gracht/types.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>


#define SERVICE_CHEF_SERVED_ID 42
#define SERVICE_CHEF_SERVED_FUNCTION_COUNT 8

#define SERVICE_CHEF_SERVED_INSTALL_ID 1
#define SERVICE_CHEF_SERVED_UPDATE_ID 2
#define SERVICE_CHEF_SERVED_SWITCH_ID 3
#define SERVICE_CHEF_SERVED_REMOVE_ID 4
#define SERVICE_CHEF_SERVED_INFO_ID 5
#define SERVICE_CHEF_SERVED_LISTCOUNT_ID 6
#define SERVICE_CHEF_SERVED_LIST_ID 7
#define SERVICE_CHEF_SERVED_LOGS_ID 8

#define SERVICE_CHEF_SERVED_EVENT_TRANSACTION_STARTED_ID 9
#define SERVICE_CHEF_SERVED_EVENT_TRANSACTION_STATE_CHANGED_ID 10
#define SERVICE_CHEF_SERVED_EVENT_TRANSACTION_COMPLETED_ID 11
#define SERVICE_CHEF_SERVED_EVENT_TRANSACTION_IO_PROGRESS_ID 12
#define SERVICE_CHEF_SERVED_EVENT_TRANSACTION_LOG_ID 13


#ifndef GRMIN
#define GRMIN(a, b) (((a)<(b))?(a):(b))
#endif //! GRMIN

#ifndef __GRACHT_SERVICE_SHARED_SERIALIZERS
#define __GRACHT_SERVICE_SHARED_SERIALIZERS
#define SERIALIZE_VALUE(name, type) static inline void serialize_##name(gracht_buffer_t* buffer, type value) { \
                                        *((type*)&buffer->data[buffer->index]) = value; buffer->index += sizeof(type); \
                                    }

#define DESERIALIZE_VALUE(name, type) static inline type deserialize_##name(gracht_buffer_t* buffer) { \
                                          type value = *((type*)&buffer->data[buffer->index]); \
                                          buffer->index += sizeof(type); \
                                          return value; \
                                       }


SERIALIZE_VALUE(uint8, uint8_t)
DESERIALIZE_VALUE(uint8, uint8_t)
SERIALIZE_VALUE(int8, int8_t)
DESERIALIZE_VALUE(int8, int8_t)
SERIALIZE_VALUE(uint16, uint16_t)
DESERIALIZE_VALUE(uint16, uint16_t)
SERIALIZE_VALUE(int16, int16_t)
DESERIALIZE_VALUE(int16, int16_t)
SERIALIZE_VALUE(uint32, uint32_t)
DESERIALIZE_VALUE(uint32, uint32_t)
SERIALIZE_VALUE(int32, int32_t)
DESERIALIZE_VALUE(int32, int32_t)
SERIALIZE_VALUE(uint64, uint64_t)
DESERIALIZE_VALUE(uint64, uint64_t)
SERIALIZE_VALUE(int64, int64_t)
DESERIALIZE_VALUE(int64, int64_t)
SERIALIZE_VALUE(long, long)
DESERIALIZE_VALUE(long, long)
SERIALIZE_VALUE(ulong, size_t)
DESERIALIZE_VALUE(ulong, size_t)
SERIALIZE_VALUE(uint, unsigned int)
DESERIALIZE_VALUE(uint, unsigned int)
SERIALIZE_VALUE(int, int)
DESERIALIZE_VALUE(int, int)
SERIALIZE_VALUE(bool, uint8_t)
DESERIALIZE_VALUE(bool, uint8_t)
SERIALIZE_VALUE(float, float)
DESERIALIZE_VALUE(float, float)
SERIALIZE_VALUE(double, double)
DESERIALIZE_VALUE(double, double)

static inline void serialize_string(gracht_buffer_t* buffer, const char* string) {
    uint32_t length = string != NULL ? (uint32_t)strlen(string) : 0;
    *((uint32_t*)&buffer->data[buffer->index]) = length;
    if (length == 0) {
        buffer->data[buffer->index + sizeof(uint32_t)] = 0;
        buffer->index += sizeof(uint32_t) + 1;
        return;
    }
    memcpy(&buffer->data[buffer->index + sizeof(uint32_t)], string, length);
    buffer->data[buffer->index + sizeof(uint32_t) + length] = 0;
    buffer->index += (sizeof(uint32_t) + length + 1);
}

static inline void deserialize_string_copy(gracht_buffer_t* buffer, char* out, uint32_t maxLength) {
    uint32_t length = *((uint32_t*)&buffer->data[buffer->index]);
    uint32_t clampedLength = GRMIN(length, maxLength - 1);
    if (clampedLength > 0) {
        memcpy(out, &buffer->data[buffer->index + sizeof(uint32_t)], clampedLength);
    }
    out[clampedLength] = 0;
    buffer->index += sizeof(uint32_t) + length + 1;
}

static inline char* deserialize_string_nocopy(gracht_buffer_t* buffer) {
    uint32_t length = *((uint32_t*)&buffer->data[buffer->index]);
    char*    string = &buffer->data[buffer->index + sizeof(uint32_t)];
    buffer->index += sizeof(uint32_t) + length + 1;
    return string;
}
#endif //! __GRACHT_SERVICE_SHARED_SERIALIZERS


struct chef_served_package;
static void serialize_chef_served_package(gracht_buffer_t* buffer, const struct chef_served_package* in);
static void deserialize_chef_served_package(gracht_buffer_t* buffer, struct chef_served_package* out);

struct chef_served_install_options;
static void serialize_chef_served_install_options(gracht_buffer_t* buffer, const struct chef_served_install_options* in);
static void deserialize_chef_served_install_options(gracht_buffer_t* buffer, struct chef_served_install_options* out);

struct chef_served_update_options;
static void serialize_chef_served_update_options(gracht_buffer_t* buffer, const struct chef_served_update_options* in);
static void deserialize_chef_served_update_options(gracht_buffer_t* buffer, struct chef_served_update_options* out);

struct chef_served_switch_options;
static void serialize_chef_served_switch_options(gracht_buffer_t* buffer, const struct chef_served_switch_options* in);
static void deserialize_chef_served_switch_options(gracht_buffer_t* buffer, struct chef_served_switch_options* out);

struct chef_transaction_started;
static void serialize_chef_transaction_started(gracht_buffer_t* buffer, const struct chef_transaction_started* in);
static void deserialize_chef_transaction_started(gracht_buffer_t* buffer, struct chef_transaction_started* out);

struct chef_transaction_completed;
static void serialize_chef_transaction_completed(gracht_buffer_t* buffer, const struct chef_transaction_completed* in);
static void deserialize_chef_transaction_completed(gracht_buffer_t* buffer, struct chef_transaction_completed* out);

struct chef_transaction_state_changed;
static void serialize_chef_transaction_state_changed(gracht_buffer_t* buffer, const struct chef_transaction_state_changed* in);
static void deserialize_chef_transaction_state_changed(gracht_buffer_t* buffer, struct chef_transaction_state_changed* out);

struct chef_transaction_io_progress;
static void serialize_chef_transaction_io_progress(gracht_buffer_t* buffer, const struct chef_transaction_io_progress* in);
static void deserialize_chef_transaction_io_progress(gracht_buffer_t* buffer, struct chef_transaction_io_progress* out);

struct chef_transaction_log_entry;
static void serialize_chef_transaction_log_entry(gracht_buffer_t* buffer, const struct chef_transaction_log_entry* in);
static void deserialize_chef_transaction_log_entry(gracht_buffer_t* buffer, struct chef_transaction_log_entry* out);

struct chef_transaction_log;
static void serialize_chef_transaction_log(gracht_buffer_t* buffer, const struct chef_transaction_log* in);
static void deserialize_chef_transaction_log(gracht_buffer_t* buffer, struct chef_transaction_log* out);


#ifndef __CHEF_INSTALL_STATUS_DEFINED__
#define __CHEF_INSTALL_STATUS_DEFINED__
enum chef_install_status {
    CHEF_INSTALL_STATUS_SUCCESS,
    CHEF_INSTALL_STATUS_FAILED_VERIFICATION,
    CHEF_INSTALL_STATUS_FAILED_INSTALL,
    CHEF_INSTALL_STATUS_FAILED_LOAD,
    CHEF_INSTALL_STATUS_FAILED_HOOKS,
};
#endif //! __CHEF_INSTALL_STATUS_DEFINED__

#ifndef __CHEF_UPDATE_STATUS_DEFINED__
#define __CHEF_UPDATE_STATUS_DEFINED__
enum chef_update_status {
    CHEF_UPDATE_STATUS_SUCCESS,
    CHEF_UPDATE_STATUS_FAILED_UNLOAD,
    CHEF_UPDATE_STATUS_FAILED_INSTALL,
    CHEF_UPDATE_STATUS_FAILED_LOAD,
    CHEF_UPDATE_STATUS_FAILED_HOOKS,
};
#endif //! __CHEF_UPDATE_STATUS_DEFINED__

#ifndef __CHEF_TRANSACTION_STATE_DEFINED__
#define __CHEF_TRANSACTION_STATE_DEFINED__
enum chef_transaction_state {
    CHEF_TRANSACTION_STATE_QUEUED,
    CHEF_TRANSACTION_STATE_PRECHECK,
    CHEF_TRANSACTION_STATE_DOWNLOADING,
    CHEF_TRANSACTION_STATE_VERIFYING,
    CHEF_TRANSACTION_STATE_RESOLVING_DEPENDENCIES,
    CHEF_TRANSACTION_STATE_INSTALLING,
    CHEF_TRANSACTION_STATE_MOUNTING,
    CHEF_TRANSACTION_STATE_LOADING,
    CHEF_TRANSACTION_STATE_STARTING_SERVICES,
    CHEF_TRANSACTION_STATE_CONFIGURING,
    CHEF_TRANSACTION_STATE_STOPPING_SERVICES,
    CHEF_TRANSACTION_STATE_UNLOADING,
    CHEF_TRANSACTION_STATE_UNMOUNTING,
    CHEF_TRANSACTION_STATE_UNINSTALLING,
    CHEF_TRANSACTION_STATE_UPDATING,
    CHEF_TRANSACTION_STATE_COMPLETED,
    CHEF_TRANSACTION_STATE_FAILED,
    CHEF_TRANSACTION_STATE_CANCELLED,
};
#endif //! __CHEF_TRANSACTION_STATE_DEFINED__

#ifndef __CHEF_TRANSACTION_RESULT_DEFINED__
#define __CHEF_TRANSACTION_RESULT_DEFINED__
enum chef_transaction_result {
    CHEF_TRANSACTION_RESULT_SUCCESS,
    CHEF_TRANSACTION_RESULT_ERROR_PRECHECK_FAILED,
    CHEF_TRANSACTION_RESULT_ERROR_DOWNLOAD_FAILED,
    CHEF_TRANSACTION_RESULT_ERROR_VERIFICATION_FAILED,
    CHEF_TRANSACTION_RESULT_ERROR_DEPENDENCY_FAILED,
    CHEF_TRANSACTION_RESULT_ERROR_INSTALL_FAILED,
    CHEF_TRANSACTION_RESULT_ERROR_MOUNT_FAILED,
    CHEF_TRANSACTION_RESULT_ERROR_LOAD_FAILED,
    CHEF_TRANSACTION_RESULT_ERROR_SERVICE_START_FAILED,
    CHEF_TRANSACTION_RESULT_ERROR_CANCELLED,
    CHEF_TRANSACTION_RESULT_ERROR_TIMEOUT,
    CHEF_TRANSACTION_RESULT_ERROR_DISK_FULL,
    CHEF_TRANSACTION_RESULT_ERROR_PERMISSION_DENIED,
    CHEF_TRANSACTION_RESULT_ERROR_UNKNOWN,
};
#endif //! __CHEF_TRANSACTION_RESULT_DEFINED__

#ifndef __CHEF_TRANSACTION_LOG_LEVEL_DEFINED__
#define __CHEF_TRANSACTION_LOG_LEVEL_DEFINED__
enum chef_transaction_log_level {
    CHEF_TRANSACTION_LOG_LEVEL_INFO = 0,
    CHEF_TRANSACTION_LOG_LEVEL_WARNING = 1,
    CHEF_TRANSACTION_LOG_LEVEL_ERROR = 2,
};
#endif //! __CHEF_TRANSACTION_LOG_LEVEL_DEFINED__


#ifndef __CHEF_SERVED_PACKAGE_DEFINED__
#define __CHEF_SERVED_PACKAGE_DEFINED__
struct chef_served_package {
    char* name;
    char* version;
};


static void chef_served_package_init(struct chef_served_package* in) {
    memset(in, 0, sizeof(struct chef_served_package));
}

static void chef_served_package_copy(const struct chef_served_package* in, struct chef_served_package* out) {
    if (in->name != NULL) {
        out->name = strdup(in->name);
    } else {
        out->name = NULL;
    }
    if (in->version != NULL) {
        out->version = strdup(in->version);
    } else {
        out->version = NULL;
    }
}

static void chef_served_package_destroy(struct chef_served_package* in) {
    if (in->name) {
        free(in->name);
    }
    if (in->version) {
        free(in->version);
    }
}

#endif //! __CHEF_SERVED_PACKAGE_DEFINED__

#ifndef __CHEF_SERVED_INSTALL_OPTIONS_DEFINED__
#define __CHEF_SERVED_INSTALL_OPTIONS_DEFINED__
struct chef_served_install_options {
    char* package;
    char* path;
    char* proof;
    char* channel;
    int revision;
};


static void chef_served_install_options_init(struct chef_served_install_options* in) {
    memset(in, 0, sizeof(struct chef_served_install_options));
}

static void chef_served_install_options_copy(const struct chef_served_install_options* in, struct chef_served_install_options* out) {
    if (in->package != NULL) {
        out->package = strdup(in->package);
    } else {
        out->package = NULL;
    }
    if (in->path != NULL) {
        out->path = strdup(in->path);
    } else {
        out->path = NULL;
    }
    if (in->proof != NULL) {
        out->proof = strdup(in->proof);
    } else {
        out->proof = NULL;
    }
    if (in->channel != NULL) {
        out->channel = strdup(in->channel);
    } else {
        out->channel = NULL;
    }
    out->revision = in->revision;
}

static void chef_served_install_options_destroy(struct chef_served_install_options* in) {
    if (in->package) {
        free(in->package);
    }
    if (in->path) {
        free(in->path);
    }
    if (in->proof) {
        free(in->proof);
    }
    if (in->channel) {
        free(in->channel);
    }
}

#endif //! __CHEF_SERVED_INSTALL_OPTIONS_DEFINED__

#ifndef __CHEF_SERVED_UPDATE_OPTIONS_DEFINED__
#define __CHEF_SERVED_UPDATE_OPTIONS_DEFINED__
struct chef_served_update_options {
    uint32_t packages_count;
    struct chef_served_package* packages;
};


static void chef_served_update_options_init(struct chef_served_update_options* in) {
    memset(in, 0, sizeof(struct chef_served_update_options));
}

static void chef_served_update_options_packages_add(struct chef_served_update_options* in, uint32_t count) {
    if (in->packages) {
        in->packages = realloc(in->packages, sizeof(struct chef_served_package) * (in->packages_count + count));
    } else {
        in->packages = malloc(sizeof(struct chef_served_package) * count);
    }
    
    for (uint32_t i = 0; i < count; i++) {
        chef_served_package_init(&in->packages[in->packages_count + i]);
    }
    in->packages_count += count;
}

static struct chef_served_package* chef_served_update_options_packages_get(struct chef_served_update_options* in, uint32_t index) {
    if (index >= in->packages_count) {
        chef_served_update_options_packages_add(in, (index - in->packages_count) + 1);
    }
    return &in->packages[index];
}

static void chef_served_update_options_copy(const struct chef_served_update_options* in, struct chef_served_update_options* out) {
    out->packages_count = in->packages_count;
    if (in->packages_count) {
        out->packages = malloc(sizeof(struct chef_served_package) * in->packages_count);
        assert(out->packages != NULL);
        for (int __i = 0; __i < in->packages_count; __i++) {
            chef_served_package_copy(&in->packages[__i], &out->packages[__i]);
        }
    } else {
        out->packages = NULL;
    }
}

static void chef_served_update_options_destroy(struct chef_served_update_options* in) {
    if (in->packages) {
        for (int __i = 0; __i < in->packages_count; __i++) {
            chef_served_package_destroy(&in->packages[__i]);
        }
        free(in->packages);
    }
}

#endif //! __CHEF_SERVED_UPDATE_OPTIONS_DEFINED__

#ifndef __CHEF_SERVED_SWITCH_OPTIONS_DEFINED__
#define __CHEF_SERVED_SWITCH_OPTIONS_DEFINED__
struct chef_served_switch_options {
    char* package;
    char* channel;
    int revision;
};


static void chef_served_switch_options_init(struct chef_served_switch_options* in) {
    memset(in, 0, sizeof(struct chef_served_switch_options));
}

static void chef_served_switch_options_copy(const struct chef_served_switch_options* in, struct chef_served_switch_options* out) {
    if (in->package != NULL) {
        out->package = strdup(in->package);
    } else {
        out->package = NULL;
    }
    if (in->channel != NULL) {
        out->channel = strdup(in->channel);
    } else {
        out->channel = NULL;
    }
    out->revision = in->revision;
}

static void chef_served_switch_options_destroy(struct chef_served_switch_options* in) {
    if (in->package) {
        free(in->package);
    }
    if (in->channel) {
        free(in->channel);
    }
}

#endif //! __CHEF_SERVED_SWITCH_OPTIONS_DEFINED__

#ifndef __CHEF_TRANSACTION_STARTED_DEFINED__
#define __CHEF_TRANSACTION_STARTED_DEFINED__
struct chef_transaction_started {
    unsigned int id;
    char* name;
    char* description;
};


static void chef_transaction_started_init(struct chef_transaction_started* in) {
    memset(in, 0, sizeof(struct chef_transaction_started));
}

static void chef_transaction_started_copy(const struct chef_transaction_started* in, struct chef_transaction_started* out) {
    out->id = in->id;
    if (in->name != NULL) {
        out->name = strdup(in->name);
    } else {
        out->name = NULL;
    }
    if (in->description != NULL) {
        out->description = strdup(in->description);
    } else {
        out->description = NULL;
    }
}

static void chef_transaction_started_destroy(struct chef_transaction_started* in) {
    if (in->name) {
        free(in->name);
    }
    if (in->description) {
        free(in->description);
    }
}

#endif //! __CHEF_TRANSACTION_STARTED_DEFINED__

#ifndef __CHEF_TRANSACTION_COMPLETED_DEFINED__
#define __CHEF_TRANSACTION_COMPLETED_DEFINED__
struct chef_transaction_completed {
    unsigned int id;
    enum chef_transaction_result result;
    char* package;
    char* message;
};


static void chef_transaction_completed_init(struct chef_transaction_completed* in) {
    memset(in, 0, sizeof(struct chef_transaction_completed));
}

static void chef_transaction_completed_copy(const struct chef_transaction_completed* in, struct chef_transaction_completed* out) {
    out->id = in->id;
    out->result = in->result;
    if (in->package != NULL) {
        out->package = strdup(in->package);
    } else {
        out->package = NULL;
    }
    if (in->message != NULL) {
        out->message = strdup(in->message);
    } else {
        out->message = NULL;
    }
}

static void chef_transaction_completed_destroy(struct chef_transaction_completed* in) {
    if (in->package) {
        free(in->package);
    }
    if (in->message) {
        free(in->message);
    }
}

#endif //! __CHEF_TRANSACTION_COMPLETED_DEFINED__

#ifndef __CHEF_TRANSACTION_STATE_CHANGED_DEFINED__
#define __CHEF_TRANSACTION_STATE_CHANGED_DEFINED__
struct chef_transaction_state_changed {
    unsigned int id;
    enum chef_transaction_state state;
    char* state_name;
    unsigned int step;
    unsigned int total_steps;
};


static void chef_transaction_state_changed_init(struct chef_transaction_state_changed* in) {
    memset(in, 0, sizeof(struct chef_transaction_state_changed));
}

static void chef_transaction_state_changed_copy(const struct chef_transaction_state_changed* in, struct chef_transaction_state_changed* out) {
    out->id = in->id;
    out->state = in->state;
    if (in->state_name != NULL) {
        out->state_name = strdup(in->state_name);
    } else {
        out->state_name = NULL;
    }
    out->step = in->step;
    out->total_steps = in->total_steps;
}

static void chef_transaction_state_changed_destroy(struct chef_transaction_state_changed* in) {
    if (in->state_name) {
        free(in->state_name);
    }
}

#endif //! __CHEF_TRANSACTION_STATE_CHANGED_DEFINED__

#ifndef __CHEF_TRANSACTION_IO_PROGRESS_DEFINED__
#define __CHEF_TRANSACTION_IO_PROGRESS_DEFINED__
struct chef_transaction_io_progress {
    unsigned int id;
    enum chef_transaction_state state;
    size_t bytes_current;
    size_t bytes_total;
    unsigned int percentage;
};


static void chef_transaction_io_progress_init(struct chef_transaction_io_progress* in) {
    memset(in, 0, sizeof(struct chef_transaction_io_progress));
}

static void chef_transaction_io_progress_copy(const struct chef_transaction_io_progress* in, struct chef_transaction_io_progress* out) {
    out->id = in->id;
    out->state = in->state;
    out->bytes_current = in->bytes_current;
    out->bytes_total = in->bytes_total;
    out->percentage = in->percentage;
}

static void chef_transaction_io_progress_destroy(struct chef_transaction_io_progress* in) {
    (void)in;
}

#endif //! __CHEF_TRANSACTION_IO_PROGRESS_DEFINED__

#ifndef __CHEF_TRANSACTION_LOG_ENTRY_DEFINED__
#define __CHEF_TRANSACTION_LOG_ENTRY_DEFINED__
struct chef_transaction_log_entry {
    enum chef_transaction_log_level level;
    size_t timestamp;
    enum chef_transaction_state state;
    char* message;
};


static void chef_transaction_log_entry_init(struct chef_transaction_log_entry* in) {
    memset(in, 0, sizeof(struct chef_transaction_log_entry));
}

static void chef_transaction_log_entry_copy(const struct chef_transaction_log_entry* in, struct chef_transaction_log_entry* out) {
    out->level = in->level;
    out->timestamp = in->timestamp;
    out->state = in->state;
    if (in->message != NULL) {
        out->message = strdup(in->message);
    } else {
        out->message = NULL;
    }
}

static void chef_transaction_log_entry_destroy(struct chef_transaction_log_entry* in) {
    if (in->message) {
        free(in->message);
    }
}

#endif //! __CHEF_TRANSACTION_LOG_ENTRY_DEFINED__

#ifndef __CHEF_TRANSACTION_LOG_DEFINED__
#define __CHEF_TRANSACTION_LOG_DEFINED__
struct chef_transaction_log {
    unsigned int id;
    struct chef_transaction_log_entry entry;
};


static void chef_transaction_log_init(struct chef_transaction_log* in) {
    memset(in, 0, sizeof(struct chef_transaction_log));
}

static void chef_transaction_log_copy(const struct chef_transaction_log* in, struct chef_transaction_log* out) {
    out->id = in->id;
    chef_transaction_log_entry_copy(&in->entry, &out->entry);
}

static void chef_transaction_log_destroy(struct chef_transaction_log* in) {
    chef_transaction_log_entry_destroy(&in->entry);
}

#endif //! __CHEF_TRANSACTION_LOG_DEFINED__

#ifndef __GRACHT_CHEF_SERVED_PACKAGE_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_SERVED_PACKAGE_SERIALIZER_DEFINED__
static void serialize_chef_served_package(gracht_buffer_t* buffer, const struct chef_served_package* in) {
    serialize_string(buffer, in->name);
    serialize_string(buffer, in->version);
}

static void deserialize_chef_served_package(gracht_buffer_t* buffer, struct chef_served_package* out) {
    uint32_t _name_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->name = malloc(_name_length + 1);
    assert(out->name != NULL);
    deserialize_string_copy(buffer, &out->name[0], 0);
    uint32_t _version_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->version = malloc(_version_length + 1);
    assert(out->version != NULL);
    deserialize_string_copy(buffer, &out->version[0], 0);
}
#endif //! __GRACHT_CHEF_SERVED_PACKAGE_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_SERVED_INSTALL_OPTIONS_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_SERVED_INSTALL_OPTIONS_SERIALIZER_DEFINED__
static void serialize_chef_served_install_options(gracht_buffer_t* buffer, const struct chef_served_install_options* in) {
    serialize_string(buffer, in->package);
    serialize_string(buffer, in->path);
    serialize_string(buffer, in->proof);
    serialize_string(buffer, in->channel);
    serialize_int(buffer, in->revision);
}

static void deserialize_chef_served_install_options(gracht_buffer_t* buffer, struct chef_served_install_options* out) {
    uint32_t _package_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->package = malloc(_package_length + 1);
    assert(out->package != NULL);
    deserialize_string_copy(buffer, &out->package[0], 0);
    uint32_t _path_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->path = malloc(_path_length + 1);
    assert(out->path != NULL);
    deserialize_string_copy(buffer, &out->path[0], 0);
    uint32_t _proof_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->proof = malloc(_proof_length + 1);
    assert(out->proof != NULL);
    deserialize_string_copy(buffer, &out->proof[0], 0);
    uint32_t _channel_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->channel = malloc(_channel_length + 1);
    assert(out->channel != NULL);
    deserialize_string_copy(buffer, &out->channel[0], 0);
    out->revision = deserialize_int(buffer);
}
#endif //! __GRACHT_CHEF_SERVED_INSTALL_OPTIONS_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_SERVED_UPDATE_OPTIONS_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_SERVED_UPDATE_OPTIONS_SERIALIZER_DEFINED__
static void serialize_chef_served_update_options(gracht_buffer_t* buffer, const struct chef_served_update_options* in) {
    serialize_uint32(buffer, in->packages_count);
    for (uint32_t __i = 0; __i < in->packages_count; __i++) {
        serialize_chef_served_package(buffer, &in->packages[__i]);
    }
}

static void deserialize_chef_served_update_options(gracht_buffer_t* buffer, struct chef_served_update_options* out) {
    out->packages_count = deserialize_uint32(buffer);
    if (out->packages_count) {
        out->packages = malloc(sizeof(struct chef_served_package) * out->packages_count);
        assert(out->packages != NULL);
        for (int __i = 0; __i < out->packages_count; __i++) {
            deserialize_chef_served_package(buffer, &out->packages[__i]);
        }
    } else {
        out->packages = NULL;
    }
}
#endif //! __GRACHT_CHEF_SERVED_UPDATE_OPTIONS_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_SERVED_SWITCH_OPTIONS_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_SERVED_SWITCH_OPTIONS_SERIALIZER_DEFINED__
static void serialize_chef_served_switch_options(gracht_buffer_t* buffer, const struct chef_served_switch_options* in) {
    serialize_string(buffer, in->package);
    serialize_string(buffer, in->channel);
    serialize_int(buffer, in->revision);
}

static void deserialize_chef_served_switch_options(gracht_buffer_t* buffer, struct chef_served_switch_options* out) {
    uint32_t _package_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->package = malloc(_package_length + 1);
    assert(out->package != NULL);
    deserialize_string_copy(buffer, &out->package[0], 0);
    uint32_t _channel_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->channel = malloc(_channel_length + 1);
    assert(out->channel != NULL);
    deserialize_string_copy(buffer, &out->channel[0], 0);
    out->revision = deserialize_int(buffer);
}
#endif //! __GRACHT_CHEF_SERVED_SWITCH_OPTIONS_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_TRANSACTION_STARTED_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_TRANSACTION_STARTED_SERIALIZER_DEFINED__
static void serialize_chef_transaction_started(gracht_buffer_t* buffer, const struct chef_transaction_started* in) {
    serialize_uint(buffer, in->id);
    serialize_string(buffer, in->name);
    serialize_string(buffer, in->description);
}

static void deserialize_chef_transaction_started(gracht_buffer_t* buffer, struct chef_transaction_started* out) {
    out->id = deserialize_uint(buffer);
    uint32_t _name_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->name = malloc(_name_length + 1);
    assert(out->name != NULL);
    deserialize_string_copy(buffer, &out->name[0], 0);
    uint32_t _description_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->description = malloc(_description_length + 1);
    assert(out->description != NULL);
    deserialize_string_copy(buffer, &out->description[0], 0);
}
#endif //! __GRACHT_CHEF_TRANSACTION_STARTED_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_TRANSACTION_COMPLETED_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_TRANSACTION_COMPLETED_SERIALIZER_DEFINED__
static void serialize_chef_transaction_completed(gracht_buffer_t* buffer, const struct chef_transaction_completed* in) {
    serialize_uint(buffer, in->id);
    serialize_int(buffer, (int)(in->result));
    serialize_string(buffer, in->package);
    serialize_string(buffer, in->message);
}

static void deserialize_chef_transaction_completed(gracht_buffer_t* buffer, struct chef_transaction_completed* out) {
    out->id = deserialize_uint(buffer);
    out->result = (enum chef_transaction_result)deserialize_int(buffer);
    uint32_t _package_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->package = malloc(_package_length + 1);
    assert(out->package != NULL);
    deserialize_string_copy(buffer, &out->package[0], 0);
    uint32_t _message_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->message = malloc(_message_length + 1);
    assert(out->message != NULL);
    deserialize_string_copy(buffer, &out->message[0], 0);
}
#endif //! __GRACHT_CHEF_TRANSACTION_COMPLETED_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_TRANSACTION_STATE_CHANGED_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_TRANSACTION_STATE_CHANGED_SERIALIZER_DEFINED__
static void serialize_chef_transaction_state_changed(gracht_buffer_t* buffer, const struct chef_transaction_state_changed* in) {
    serialize_uint(buffer, in->id);
    serialize_int(buffer, (int)(in->state));
    serialize_string(buffer, in->state_name);
    serialize_uint(buffer, in->step);
    serialize_uint(buffer, in->total_steps);
}

static void deserialize_chef_transaction_state_changed(gracht_buffer_t* buffer, struct chef_transaction_state_changed* out) {
    out->id = deserialize_uint(buffer);
    out->state = (enum chef_transaction_state)deserialize_int(buffer);
    uint32_t _state_name_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->state_name = malloc(_state_name_length + 1);
    assert(out->state_name != NULL);
    deserialize_string_copy(buffer, &out->state_name[0], 0);
    out->step = deserialize_uint(buffer);
    out->total_steps = deserialize_uint(buffer);
}
#endif //! __GRACHT_CHEF_TRANSACTION_STATE_CHANGED_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_TRANSACTION_IO_PROGRESS_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_TRANSACTION_IO_PROGRESS_SERIALIZER_DEFINED__
static void serialize_chef_transaction_io_progress(gracht_buffer_t* buffer, const struct chef_transaction_io_progress* in) {
    serialize_uint(buffer, in->id);
    serialize_int(buffer, (int)(in->state));
    serialize_ulong(buffer, in->bytes_current);
    serialize_ulong(buffer, in->bytes_total);
    serialize_uint(buffer, in->percentage);
}

static void deserialize_chef_transaction_io_progress(gracht_buffer_t* buffer, struct chef_transaction_io_progress* out) {
    out->id = deserialize_uint(buffer);
    out->state = (enum chef_transaction_state)deserialize_int(buffer);
    out->bytes_current = deserialize_ulong(buffer);
    out->bytes_total = deserialize_ulong(buffer);
    out->percentage = deserialize_uint(buffer);
}
#endif //! __GRACHT_CHEF_TRANSACTION_IO_PROGRESS_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_TRANSACTION_LOG_ENTRY_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_TRANSACTION_LOG_ENTRY_SERIALIZER_DEFINED__
static void serialize_chef_transaction_log_entry(gracht_buffer_t* buffer, const struct chef_transaction_log_entry* in) {
    serialize_int(buffer, (int)(in->level));
    serialize_ulong(buffer, in->timestamp);
    serialize_int(buffer, (int)(in->state));
    serialize_string(buffer, in->message);
}

static void deserialize_chef_transaction_log_entry(gracht_buffer_t* buffer, struct chef_transaction_log_entry* out) {
    out->level = (enum chef_transaction_log_level)deserialize_int(buffer);
    out->timestamp = deserialize_ulong(buffer);
    out->state = (enum chef_transaction_state)deserialize_int(buffer);
    uint32_t _message_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->message = malloc(_message_length + 1);
    assert(out->message != NULL);
    deserialize_string_copy(buffer, &out->message[0], 0);
}
#endif //! __GRACHT_CHEF_TRANSACTION_LOG_ENTRY_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_TRANSACTION_LOG_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_TRANSACTION_LOG_SERIALIZER_DEFINED__
static void serialize_chef_transaction_log(gracht_buffer_t* buffer, const struct chef_transaction_log* in) {
    serialize_uint(buffer, in->id);
    serialize_chef_transaction_log_entry(buffer, &in->entry);
}

static void deserialize_chef_transaction_log(gracht_buffer_t* buffer, struct chef_transaction_log* out) {
    out->id = deserialize_uint(buffer);
    deserialize_chef_transaction_log_entry(buffer, &out->entry);
}
#endif //! __GRACHT_CHEF_TRANSACTION_LOG_SERIALIZER_DEFINED__

#endif //! __CHEF_SERVED_SERVICE_H__
