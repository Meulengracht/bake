/**
* This file was generated by the gracht service generator script. Any changes done here will be overwritten.
 */

#ifndef __CHEF_CVD_SERVICE_H__
#define __CHEF_CVD_SERVICE_H__

#include <assert.h>
#include <gracht/types.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>


#define SERVICE_CHEF_CVD_ID 43
#define SERVICE_CHEF_CVD_FUNCTION_COUNT 6

#define SERVICE_CHEF_CVD_CREATE_ID 1
#define SERVICE_CHEF_CVD_SPAWN_ID 2
#define SERVICE_CHEF_CVD_KILL_ID 3
#define SERVICE_CHEF_CVD_UPLOAD_ID 4
#define SERVICE_CHEF_CVD_DOWNLOAD_ID 5
#define SERVICE_CHEF_CVD_DESTROY_ID 6


#ifndef GRMIN
#define GRMIN(a, b) (((a)<(b))?(a):(b))
#endif //! GRMIN

#ifndef __GRACHT_SERVICE_SHARED_SERIALIZERS
#define __GRACHT_SERVICE_SHARED_SERIALIZERS
#define SERIALIZE_VALUE(name, type) static inline void serialize_##name(gracht_buffer_t* buffer, type value) { \
                                        *((type*)&buffer->data[buffer->index]) = value; buffer->index += sizeof(type); \
                                    }

#define DESERIALIZE_VALUE(name, type) static inline type deserialize_##name(gracht_buffer_t* buffer) { \
                                          type value = *((type*)&buffer->data[buffer->index]); \
                                          buffer->index += sizeof(type); \
                                          return value; \
                                       }


SERIALIZE_VALUE(uint8, uint8_t)
DESERIALIZE_VALUE(uint8, uint8_t)
SERIALIZE_VALUE(int8, int8_t)
DESERIALIZE_VALUE(int8, int8_t)
SERIALIZE_VALUE(uint16, uint16_t)
DESERIALIZE_VALUE(uint16, uint16_t)
SERIALIZE_VALUE(int16, int16_t)
DESERIALIZE_VALUE(int16, int16_t)
SERIALIZE_VALUE(uint32, uint32_t)
DESERIALIZE_VALUE(uint32, uint32_t)
SERIALIZE_VALUE(int32, int32_t)
DESERIALIZE_VALUE(int32, int32_t)
SERIALIZE_VALUE(uint64, uint64_t)
DESERIALIZE_VALUE(uint64, uint64_t)
SERIALIZE_VALUE(int64, int64_t)
DESERIALIZE_VALUE(int64, int64_t)
SERIALIZE_VALUE(long, long)
DESERIALIZE_VALUE(long, long)
SERIALIZE_VALUE(ulong, size_t)
DESERIALIZE_VALUE(ulong, size_t)
SERIALIZE_VALUE(uint, unsigned int)
DESERIALIZE_VALUE(uint, unsigned int)
SERIALIZE_VALUE(int, int)
DESERIALIZE_VALUE(int, int)
SERIALIZE_VALUE(bool, uint8_t)
DESERIALIZE_VALUE(bool, uint8_t)
SERIALIZE_VALUE(float, float)
DESERIALIZE_VALUE(float, float)
SERIALIZE_VALUE(double, double)
DESERIALIZE_VALUE(double, double)

static inline void serialize_string(gracht_buffer_t* buffer, const char* string) {
    uint32_t length = string != NULL ? (uint32_t)strlen(string) : 0;
    *((uint32_t*)&buffer->data[buffer->index]) = length;
    if (length == 0) {
        buffer->data[buffer->index + sizeof(uint32_t)] = 0;
        buffer->index += sizeof(uint32_t) + 1;
        return;
    }
    memcpy(&buffer->data[buffer->index + sizeof(uint32_t)], string, length);
    buffer->data[buffer->index + sizeof(uint32_t) + length] = 0;
    buffer->index += (sizeof(uint32_t) + length + 1);
}

static inline void deserialize_string_copy(gracht_buffer_t* buffer, char* out, uint32_t maxLength) {
    uint32_t length = *((uint32_t*)&buffer->data[buffer->index]);
    uint32_t clampedLength = GRMIN(length, maxLength - 1);
    if (clampedLength > 0) {
        memcpy(out, &buffer->data[buffer->index + sizeof(uint32_t)], clampedLength);
    }
    out[clampedLength] = 0;
    buffer->index += sizeof(uint32_t) + length + 1;
}

static inline char* deserialize_string_nocopy(gracht_buffer_t* buffer) {
    uint32_t length = *((uint32_t*)&buffer->data[buffer->index]);
    char*    string = &buffer->data[buffer->index + sizeof(uint32_t)];
    buffer->index += sizeof(uint32_t) + length + 1;
    return string;
}
#endif //! __GRACHT_SERVICE_SHARED_SERIALIZERS


struct chef_layer_descriptor;
static void serialize_chef_layer_descriptor(gracht_buffer_t* buffer, const struct chef_layer_descriptor* in);
static void deserialize_chef_layer_descriptor(gracht_buffer_t* buffer, struct chef_layer_descriptor* out);

struct chef_create_parameters;
static void serialize_chef_create_parameters(gracht_buffer_t* buffer, const struct chef_create_parameters* in);
static void deserialize_chef_create_parameters(gracht_buffer_t* buffer, struct chef_create_parameters* out);

struct chef_user_descriptor;
static void serialize_chef_user_descriptor(gracht_buffer_t* buffer, const struct chef_user_descriptor* in);
static void deserialize_chef_user_descriptor(gracht_buffer_t* buffer, struct chef_user_descriptor* out);

struct chef_spawn_parameters;
static void serialize_chef_spawn_parameters(gracht_buffer_t* buffer, const struct chef_spawn_parameters* in);
static void deserialize_chef_spawn_parameters(gracht_buffer_t* buffer, struct chef_spawn_parameters* out);

struct chef_file_parameters;
static void serialize_chef_file_parameters(gracht_buffer_t* buffer, const struct chef_file_parameters* in);
static void deserialize_chef_file_parameters(gracht_buffer_t* buffer, struct chef_file_parameters* out);


#ifndef __CHEF_CAPABILITIES_DEFINED__
#define __CHEF_CAPABILITIES_DEFINED__
enum chef_capabilities {
    CHEF_CAPABILITIES_NETWORK = 1,
    CHEF_CAPABILITIES_PROCESS_CONTROL = 2,
    CHEF_CAPABILITIES_IPC = 4,
    CHEF_CAPABILITIES_FILESYSTEM = 8,
    CHEF_CAPABILITIES_CGROUPS = 16,
    CHEF_CAPABILITIES_USERS = 32,
};
#endif //! __CHEF_CAPABILITIES_DEFINED__

#ifndef __CHEF_MOUNT_OPTIONS_DEFINED__
#define __CHEF_MOUNT_OPTIONS_DEFINED__
enum chef_mount_options {
    CHEF_MOUNT_OPTIONS_READONLY = 1,
};
#endif //! __CHEF_MOUNT_OPTIONS_DEFINED__

#ifndef __CHEF_LAYER_TYPE_DEFINED__
#define __CHEF_LAYER_TYPE_DEFINED__
enum chef_layer_type {
    CHEF_LAYER_TYPE_BASE_ROOTFS,
    CHEF_LAYER_TYPE_VAFS_PACKAGE,
    CHEF_LAYER_TYPE_HOST_DIRECTORY,
    CHEF_LAYER_TYPE_OVERLAY,
};
#endif //! __CHEF_LAYER_TYPE_DEFINED__

#ifndef __CHEF_STATUS_DEFINED__
#define __CHEF_STATUS_DEFINED__
enum chef_status {
    CHEF_STATUS_SUCCESS,
    CHEF_STATUS_INTERNAL_ERROR,
    CHEF_STATUS_CONTAINER_EXISTS,
    CHEF_STATUS_FAILED_ROOTFS_SETUP,
    CHEF_STATUS_INVALID_MOUNTS,
    CHEF_STATUS_INVALID_CONTAINER_ID,
};
#endif //! __CHEF_STATUS_DEFINED__

#ifndef __CHEF_SPAWN_OPTIONS_DEFINED__
#define __CHEF_SPAWN_OPTIONS_DEFINED__
enum chef_spawn_options {
    CHEF_SPAWN_OPTIONS_WAIT = 1,
};
#endif //! __CHEF_SPAWN_OPTIONS_DEFINED__


#ifndef __CHEF_LAYER_DESCRIPTOR_DEFINED__
#define __CHEF_LAYER_DESCRIPTOR_DEFINED__
struct chef_layer_descriptor {
    enum chef_layer_type type;
    char* source;
    char* target;
    enum chef_mount_options options;
};


static void chef_layer_descriptor_init(struct chef_layer_descriptor* in) {
    memset(in, 0, sizeof(struct chef_layer_descriptor));
}

static void chef_layer_descriptor_copy(const struct chef_layer_descriptor* in, struct chef_layer_descriptor* out) {
    out->type = in->type;
    if (in->source != NULL) {
        out->source = strdup(in->source);
    } else {
        out->source = NULL;
    }
    if (in->target != NULL) {
        out->target = strdup(in->target);
    } else {
        out->target = NULL;
    }
    out->options = in->options;
}

static void chef_layer_descriptor_destroy(struct chef_layer_descriptor* in) {
    if (in->source) {
        free(in->source);
    }
    if (in->target) {
        free(in->target);
    }
}

#endif //! __CHEF_LAYER_DESCRIPTOR_DEFINED__

#ifndef __CHEF_CREATE_PARAMETERS_DEFINED__
#define __CHEF_CREATE_PARAMETERS_DEFINED__
struct chef_create_parameters {
    char* id;
    uint32_t layers_count;
    struct chef_layer_descriptor* layers;
};


static void chef_create_parameters_init(struct chef_create_parameters* in) {
    memset(in, 0, sizeof(struct chef_create_parameters));
}

static void chef_create_parameters_layers_add(struct chef_create_parameters* in, uint32_t count) {
    if (in->layers) {
        in->layers = realloc(in->layers, sizeof(struct chef_layer_descriptor) * (in->layers_count + count));
    } else {
        in->layers = malloc(sizeof(struct chef_layer_descriptor) * count);
    }
    
    for (uint32_t i = 0; i < count; i++) {
        chef_layer_descriptor_init(&in->layers[in->layers_count + i]);
    }
    in->layers_count += count;
}

static struct chef_layer_descriptor* chef_create_parameters_layers_get(struct chef_create_parameters* in, uint32_t index) {
    if (index >= in->layers_count) {
        chef_create_parameters_layers_add(in, (index - in->layers_count) + 1);
    }
    return &in->layers[index];
}

static void chef_create_parameters_copy(const struct chef_create_parameters* in, struct chef_create_parameters* out) {
    if (in->id != NULL) {
        out->id = strdup(in->id);
    } else {
        out->id = NULL;
    }
    out->layers_count = in->layers_count;
    if (in->layers_count) {
        out->layers = malloc(sizeof(struct chef_layer_descriptor) * in->layers_count);
        assert(out->layers != NULL);
        for (int __i = 0; __i < in->layers_count; __i++) {
            chef_layer_descriptor_copy(&in->layers[__i], &out->layers[__i]);
        }
    } else {
        out->layers = NULL;
    }
}

static void chef_create_parameters_destroy(struct chef_create_parameters* in) {
    if (in->id) {
        free(in->id);
    }
    if (in->layers) {
        for (int __i = 0; __i < in->layers_count; __i++) {
            chef_layer_descriptor_destroy(&in->layers[__i]);
        }
        free(in->layers);
    }
}

#endif //! __CHEF_CREATE_PARAMETERS_DEFINED__

#ifndef __CHEF_USER_DESCRIPTOR_DEFINED__
#define __CHEF_USER_DESCRIPTOR_DEFINED__
struct chef_user_descriptor {
    char* username;
};


static void chef_user_descriptor_init(struct chef_user_descriptor* in) {
    memset(in, 0, sizeof(struct chef_user_descriptor));
}

static void chef_user_descriptor_copy(const struct chef_user_descriptor* in, struct chef_user_descriptor* out) {
    if (in->username != NULL) {
        out->username = strdup(in->username);
    } else {
        out->username = NULL;
    }
}

static void chef_user_descriptor_destroy(struct chef_user_descriptor* in) {
    if (in->username) {
        free(in->username);
    }
}

#endif //! __CHEF_USER_DESCRIPTOR_DEFINED__

#ifndef __CHEF_SPAWN_PARAMETERS_DEFINED__
#define __CHEF_SPAWN_PARAMETERS_DEFINED__
struct chef_spawn_parameters {
    char* container_id;
    struct chef_user_descriptor user;
    enum chef_spawn_options options;
    char* command;
    uint32_t environment_count;
    uint8_t* environment;
};


static void chef_spawn_parameters_init(struct chef_spawn_parameters* in) {
    memset(in, 0, sizeof(struct chef_spawn_parameters));
}

static void chef_spawn_parameters_copy(const struct chef_spawn_parameters* in, struct chef_spawn_parameters* out) {
    if (in->container_id != NULL) {
        out->container_id = strdup(in->container_id);
    } else {
        out->container_id = NULL;
    }
    chef_user_descriptor_copy(&in->user, &out->user);
    out->options = in->options;
    if (in->command != NULL) {
        out->command = strdup(in->command);
    } else {
        out->command = NULL;
    }
    out->environment_count = in->environment_count;
    if (in->environment_count) {
        out->environment = malloc(sizeof(uint8_t) * in->environment_count);
        assert(out->environment != NULL);
        memcpy(out->environment, in->environment, in->environment_count);
    } else {
        out->environment = NULL;
    }
}

static void chef_spawn_parameters_destroy(struct chef_spawn_parameters* in) {
    if (in->container_id) {
        free(in->container_id);
    }
    chef_user_descriptor_destroy(&in->user);
    if (in->command) {
        free(in->command);
    }
    if (in->environment) {
        free(in->environment);
    }
}

#endif //! __CHEF_SPAWN_PARAMETERS_DEFINED__

#ifndef __CHEF_FILE_PARAMETERS_DEFINED__
#define __CHEF_FILE_PARAMETERS_DEFINED__
struct chef_file_parameters {
    char* container_id;
    struct chef_user_descriptor user;
    char* source_path;
    char* destination_path;
};


static void chef_file_parameters_init(struct chef_file_parameters* in) {
    memset(in, 0, sizeof(struct chef_file_parameters));
}

static void chef_file_parameters_copy(const struct chef_file_parameters* in, struct chef_file_parameters* out) {
    if (in->container_id != NULL) {
        out->container_id = strdup(in->container_id);
    } else {
        out->container_id = NULL;
    }
    chef_user_descriptor_copy(&in->user, &out->user);
    if (in->source_path != NULL) {
        out->source_path = strdup(in->source_path);
    } else {
        out->source_path = NULL;
    }
    if (in->destination_path != NULL) {
        out->destination_path = strdup(in->destination_path);
    } else {
        out->destination_path = NULL;
    }
}

static void chef_file_parameters_destroy(struct chef_file_parameters* in) {
    if (in->container_id) {
        free(in->container_id);
    }
    chef_user_descriptor_destroy(&in->user);
    if (in->source_path) {
        free(in->source_path);
    }
    if (in->destination_path) {
        free(in->destination_path);
    }
}

#endif //! __CHEF_FILE_PARAMETERS_DEFINED__

#ifndef __GRACHT_CHEF_LAYER_DESCRIPTOR_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_LAYER_DESCRIPTOR_SERIALIZER_DEFINED__
static void serialize_chef_layer_descriptor(gracht_buffer_t* buffer, const struct chef_layer_descriptor* in) {
    serialize_int(buffer, (int)(in->type));
    serialize_string(buffer, in->source);
    serialize_string(buffer, in->target);
    serialize_int(buffer, (int)(in->options));
}

static void deserialize_chef_layer_descriptor(gracht_buffer_t* buffer, struct chef_layer_descriptor* out) {
    out->type = (enum chef_layer_type)deserialize_int(buffer);
    uint32_t _source_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->source = malloc(_source_length + 1);
    assert(out->source != NULL);
    deserialize_string_copy(buffer, &out->source[0], 0);
    uint32_t _target_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->target = malloc(_target_length + 1);
    assert(out->target != NULL);
    deserialize_string_copy(buffer, &out->target[0], 0);
    out->options = (enum chef_mount_options)deserialize_int(buffer);
}
#endif //! __GRACHT_CHEF_LAYER_DESCRIPTOR_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_CREATE_PARAMETERS_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_CREATE_PARAMETERS_SERIALIZER_DEFINED__
static void serialize_chef_create_parameters(gracht_buffer_t* buffer, const struct chef_create_parameters* in) {
    serialize_string(buffer, in->id);
    serialize_uint32(buffer, in->layers_count);
    for (uint32_t __i = 0; __i < in->layers_count; __i++) {
        serialize_chef_layer_descriptor(buffer, &in->layers[__i]);
    }
}

static void deserialize_chef_create_parameters(gracht_buffer_t* buffer, struct chef_create_parameters* out) {
    uint32_t _id_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->id = malloc(_id_length + 1);
    assert(out->id != NULL);
    deserialize_string_copy(buffer, &out->id[0], 0);
    out->layers_count = deserialize_uint32(buffer);
    if (out->layers_count) {
        out->layers = malloc(sizeof(struct chef_layer_descriptor) * out->layers_count);
        assert(out->layers != NULL);
        for (int __i = 0; __i < out->layers_count; __i++) {
            deserialize_chef_layer_descriptor(buffer, &out->layers[__i]);
        }
    } else {
        out->layers = NULL;
    }
}
#endif //! __GRACHT_CHEF_CREATE_PARAMETERS_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_USER_DESCRIPTOR_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_USER_DESCRIPTOR_SERIALIZER_DEFINED__
static void serialize_chef_user_descriptor(gracht_buffer_t* buffer, const struct chef_user_descriptor* in) {
    serialize_string(buffer, in->username);
}

static void deserialize_chef_user_descriptor(gracht_buffer_t* buffer, struct chef_user_descriptor* out) {
    uint32_t _username_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->username = malloc(_username_length + 1);
    assert(out->username != NULL);
    deserialize_string_copy(buffer, &out->username[0], 0);
}
#endif //! __GRACHT_CHEF_USER_DESCRIPTOR_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_SPAWN_PARAMETERS_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_SPAWN_PARAMETERS_SERIALIZER_DEFINED__
static void serialize_chef_spawn_parameters(gracht_buffer_t* buffer, const struct chef_spawn_parameters* in) {
    serialize_string(buffer, in->container_id);
    serialize_chef_user_descriptor(buffer, &in->user);
    serialize_int(buffer, (int)(in->options));
    serialize_string(buffer, in->command);
    serialize_uint32(buffer, in->environment_count);
    memcpy(&buffer->data[buffer->index], &in->environment[0], sizeof(uint8_t) * in->environment_count);
    buffer->index += sizeof(uint8_t) * in->environment_count;
}

static void deserialize_chef_spawn_parameters(gracht_buffer_t* buffer, struct chef_spawn_parameters* out) {
    uint32_t _container_id_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->container_id = malloc(_container_id_length + 1);
    assert(out->container_id != NULL);
    deserialize_string_copy(buffer, &out->container_id[0], 0);
    deserialize_chef_user_descriptor(buffer, &out->user);
    out->options = (enum chef_spawn_options)deserialize_int(buffer);
    uint32_t _command_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->command = malloc(_command_length + 1);
    assert(out->command != NULL);
    deserialize_string_copy(buffer, &out->command[0], 0);
    out->environment_count = deserialize_uint32(buffer);
    if (out->environment_count) {
        out->environment = malloc(sizeof(uint8_t) * out->environment_count);
        assert(out->environment != NULL);
        memcpy(&out->environment[0], &buffer->data[buffer->index], sizeof(uint8_t) * out->environment_count);
        buffer->index += sizeof(uint8_t) * out->environment_count;
    } else {
        out->environment = NULL;
    }
}
#endif //! __GRACHT_CHEF_SPAWN_PARAMETERS_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_FILE_PARAMETERS_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_FILE_PARAMETERS_SERIALIZER_DEFINED__
static void serialize_chef_file_parameters(gracht_buffer_t* buffer, const struct chef_file_parameters* in) {
    serialize_string(buffer, in->container_id);
    serialize_chef_user_descriptor(buffer, &in->user);
    serialize_string(buffer, in->source_path);
    serialize_string(buffer, in->destination_path);
}

static void deserialize_chef_file_parameters(gracht_buffer_t* buffer, struct chef_file_parameters* out) {
    uint32_t _container_id_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->container_id = malloc(_container_id_length + 1);
    assert(out->container_id != NULL);
    deserialize_string_copy(buffer, &out->container_id[0], 0);
    deserialize_chef_user_descriptor(buffer, &out->user);
    uint32_t _source_path_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->source_path = malloc(_source_path_length + 1);
    assert(out->source_path != NULL);
    deserialize_string_copy(buffer, &out->source_path[0], 0);
    uint32_t _destination_path_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->destination_path = malloc(_destination_path_length + 1);
    assert(out->destination_path != NULL);
    deserialize_string_copy(buffer, &out->destination_path[0], 0);
}
#endif //! __GRACHT_CHEF_FILE_PARAMETERS_SERIALIZER_DEFINED__

#endif //! __CHEF_CVD_SERVICE_H__
