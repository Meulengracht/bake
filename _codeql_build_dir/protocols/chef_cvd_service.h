/**
* This file was generated by the gracht service generator script. Any changes done here will be overwritten.
 */

#ifndef __CHEF_CVD_SERVICE_H__
#define __CHEF_CVD_SERVICE_H__

#include <assert.h>
#include <gracht/types.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>


#define SERVICE_CHEF_CVD_ID 43
#define SERVICE_CHEF_CVD_FUNCTION_COUNT 6

#define SERVICE_CHEF_CVD_CREATE_ID 1
#define SERVICE_CHEF_CVD_SPAWN_ID 2
#define SERVICE_CHEF_CVD_KILL_ID 3
#define SERVICE_CHEF_CVD_UPLOAD_ID 4
#define SERVICE_CHEF_CVD_DOWNLOAD_ID 5
#define SERVICE_CHEF_CVD_DESTROY_ID 6


#ifndef GRMIN
#define GRMIN(a, b) (((a)<(b))?(a):(b))
#endif //! GRMIN

#ifndef __GRACHT_SERVICE_SHARED_SERIALIZERS
#define __GRACHT_SERVICE_SHARED_SERIALIZERS
#define SERIALIZE_VALUE(name, type) static inline void serialize_##name(gracht_buffer_t* buffer, type value) { \
                                        *((type*)&buffer->data[buffer->index]) = value; buffer->index += sizeof(type); \
                                    }

#define DESERIALIZE_VALUE(name, type) static inline type deserialize_##name(gracht_buffer_t* buffer) { \
                                          type value = *((type*)&buffer->data[buffer->index]); \
                                          buffer->index += sizeof(type); \
                                          return value; \
                                       }


SERIALIZE_VALUE(uint8, uint8_t)
DESERIALIZE_VALUE(uint8, uint8_t)
SERIALIZE_VALUE(int8, int8_t)
DESERIALIZE_VALUE(int8, int8_t)
SERIALIZE_VALUE(uint16, uint16_t)
DESERIALIZE_VALUE(uint16, uint16_t)
SERIALIZE_VALUE(int16, int16_t)
DESERIALIZE_VALUE(int16, int16_t)
SERIALIZE_VALUE(uint32, uint32_t)
DESERIALIZE_VALUE(uint32, uint32_t)
SERIALIZE_VALUE(int32, int32_t)
DESERIALIZE_VALUE(int32, int32_t)
SERIALIZE_VALUE(uint64, uint64_t)
DESERIALIZE_VALUE(uint64, uint64_t)
SERIALIZE_VALUE(int64, int64_t)
DESERIALIZE_VALUE(int64, int64_t)
SERIALIZE_VALUE(long, long)
DESERIALIZE_VALUE(long, long)
SERIALIZE_VALUE(ulong, size_t)
DESERIALIZE_VALUE(ulong, size_t)
SERIALIZE_VALUE(uint, unsigned int)
DESERIALIZE_VALUE(uint, unsigned int)
SERIALIZE_VALUE(int, int)
DESERIALIZE_VALUE(int, int)
SERIALIZE_VALUE(bool, uint8_t)
DESERIALIZE_VALUE(bool, uint8_t)
SERIALIZE_VALUE(float, float)
DESERIALIZE_VALUE(float, float)
SERIALIZE_VALUE(double, double)
DESERIALIZE_VALUE(double, double)

static inline void serialize_string(gracht_buffer_t* buffer, const char* string) {
    uint32_t length = string != NULL ? (uint32_t)strlen(string) : 0;
    *((uint32_t*)&buffer->data[buffer->index]) = length;
    if (length == 0) {
        buffer->data[buffer->index + sizeof(uint32_t)] = 0;
        buffer->index += sizeof(uint32_t) + 1;
        return;
    }
    memcpy(&buffer->data[buffer->index + sizeof(uint32_t)], string, length);
    buffer->data[buffer->index + sizeof(uint32_t) + length] = 0;
    buffer->index += (sizeof(uint32_t) + length + 1);
}

static inline void deserialize_string_copy(gracht_buffer_t* buffer, char* out, uint32_t maxLength) {
    uint32_t length = *((uint32_t*)&buffer->data[buffer->index]);
    uint32_t clampedLength = GRMIN(length, maxLength - 1);
    if (clampedLength > 0) {
        memcpy(out, &buffer->data[buffer->index + sizeof(uint32_t)], clampedLength);
    }
    out[clampedLength] = 0;
    buffer->index += sizeof(uint32_t) + length + 1;
}

static inline char* deserialize_string_nocopy(gracht_buffer_t* buffer) {
    uint32_t length = *((uint32_t*)&buffer->data[buffer->index]);
    char*    string = &buffer->data[buffer->index + sizeof(uint32_t)];
    buffer->index += sizeof(uint32_t) + length + 1;
    return string;
}
#endif //! __GRACHT_SERVICE_SHARED_SERIALIZERS


struct chef_container_mount;
static void serialize_chef_container_mount(gracht_buffer_t* buffer, const struct chef_container_mount* in);
static void deserialize_chef_container_mount(gracht_buffer_t* buffer, struct chef_container_mount* out);

struct chef_create_parameters;
static void serialize_chef_create_parameters(gracht_buffer_t* buffer, const struct chef_create_parameters* in);
static void deserialize_chef_create_parameters(gracht_buffer_t* buffer, struct chef_create_parameters* out);

struct chef_user_descriptor;
static void serialize_chef_user_descriptor(gracht_buffer_t* buffer, const struct chef_user_descriptor* in);
static void deserialize_chef_user_descriptor(gracht_buffer_t* buffer, struct chef_user_descriptor* out);

struct chef_spawn_parameters;
static void serialize_chef_spawn_parameters(gracht_buffer_t* buffer, const struct chef_spawn_parameters* in);
static void deserialize_chef_spawn_parameters(gracht_buffer_t* buffer, struct chef_spawn_parameters* out);

struct chef_file_parameters;
static void serialize_chef_file_parameters(gracht_buffer_t* buffer, const struct chef_file_parameters* in);
static void deserialize_chef_file_parameters(gracht_buffer_t* buffer, struct chef_file_parameters* out);


#ifndef __CHEF_CAPABILITIES_DEFINED__
#define __CHEF_CAPABILITIES_DEFINED__
enum chef_capabilities {
    CHEF_CAPABILITIES_NETWORK = 1,
    CHEF_CAPABILITIES_PROCESS_CONTROL = 2,
    CHEF_CAPABILITIES_IPC = 4,
    CHEF_CAPABILITIES_FILESYSTEM = 8,
    CHEF_CAPABILITIES_CGROUPS = 16,
    CHEF_CAPABILITIES_USERS = 32,
};
#endif //! __CHEF_CAPABILITIES_DEFINED__

#ifndef __CHEF_ROOTFS_TYPE_DEFINED__
#define __CHEF_ROOTFS_TYPE_DEFINED__
enum chef_rootfs_type {
    CHEF_ROOTFS_TYPE_DEBOOTSTRAP,
    CHEF_ROOTFS_TYPE_OSBASE,
    CHEF_ROOTFS_TYPE_IMAGE,
};
#endif //! __CHEF_ROOTFS_TYPE_DEFINED__

#ifndef __CHEF_STATUS_DEFINED__
#define __CHEF_STATUS_DEFINED__
enum chef_status {
    CHEF_STATUS_SUCCESS,
    CHEF_STATUS_INTERNAL_ERROR,
    CHEF_STATUS_FAILED_ROOTFS_SETUP,
    CHEF_STATUS_INVALID_MOUNTS,
    CHEF_STATUS_INVALID_CONTAINER_ID,
};
#endif //! __CHEF_STATUS_DEFINED__

#ifndef __CHEF_MOUNT_OPTIONS_DEFINED__
#define __CHEF_MOUNT_OPTIONS_DEFINED__
enum chef_mount_options {
    CHEF_MOUNT_OPTIONS_READONLY = 1,
};
#endif //! __CHEF_MOUNT_OPTIONS_DEFINED__

#ifndef __CHEF_SPAWN_OPTIONS_DEFINED__
#define __CHEF_SPAWN_OPTIONS_DEFINED__
enum chef_spawn_options {
    CHEF_SPAWN_OPTIONS_WAIT = 1,
};
#endif //! __CHEF_SPAWN_OPTIONS_DEFINED__


#ifndef __CHEF_CONTAINER_MOUNT_DEFINED__
#define __CHEF_CONTAINER_MOUNT_DEFINED__
struct chef_container_mount {
    char* host_path;
    char* container_path;
    enum chef_mount_options options;
};


static void chef_container_mount_init(struct chef_container_mount* in) {
    memset(in, 0, sizeof(struct chef_container_mount));
}

static void chef_container_mount_copy(const struct chef_container_mount* in, struct chef_container_mount* out) {
    if (in->host_path != NULL) {
        out->host_path = strdup(in->host_path);
    } else {
        out->host_path = NULL;
    }
    if (in->container_path != NULL) {
        out->container_path = strdup(in->container_path);
    } else {
        out->container_path = NULL;
    }
    out->options = in->options;
}

static void chef_container_mount_destroy(struct chef_container_mount* in) {
    if (in->host_path) {
        free(in->host_path);
    }
    if (in->container_path) {
        free(in->container_path);
    }
}

#endif //! __CHEF_CONTAINER_MOUNT_DEFINED__

#ifndef __CHEF_CREATE_PARAMETERS_DEFINED__
#define __CHEF_CREATE_PARAMETERS_DEFINED__
struct chef_create_parameters {
    char* rootfs;
    enum chef_rootfs_type type;
    uint32_t mounts_count;
    struct chef_container_mount* mounts;
};


static void chef_create_parameters_init(struct chef_create_parameters* in) {
    memset(in, 0, sizeof(struct chef_create_parameters));
}

static void chef_create_parameters_mounts_add(struct chef_create_parameters* in, uint32_t count) {
    if (in->mounts) {
        in->mounts = realloc(in->mounts, sizeof(struct chef_container_mount) * (in->mounts_count + count));
    } else {
        in->mounts = malloc(sizeof(struct chef_container_mount) * count);
    }
    
    for (uint32_t i = 0; i < count; i++) {
        chef_container_mount_init(&in->mounts[in->mounts_count + i]);
    }
    in->mounts_count += count;
}

static struct chef_container_mount* chef_create_parameters_mounts_get(struct chef_create_parameters* in, uint32_t index) {
    if (index >= in->mounts_count) {
        chef_create_parameters_mounts_add(in, (index - in->mounts_count) + 1);
    }
    return &in->mounts[index];
}

static void chef_create_parameters_copy(const struct chef_create_parameters* in, struct chef_create_parameters* out) {
    if (in->rootfs != NULL) {
        out->rootfs = strdup(in->rootfs);
    } else {
        out->rootfs = NULL;
    }
    out->type = in->type;
    out->mounts_count = in->mounts_count;
    if (in->mounts_count) {
        out->mounts = malloc(sizeof(struct chef_container_mount) * in->mounts_count);
        assert(out->mounts != NULL);
        for (int __i = 0; __i < in->mounts_count; __i++) {
            chef_container_mount_copy(&in->mounts[__i], &out->mounts[__i]);
        }
    } else {
        out->mounts = NULL;
    }
}

static void chef_create_parameters_destroy(struct chef_create_parameters* in) {
    if (in->rootfs) {
        free(in->rootfs);
    }
    if (in->mounts) {
        for (int __i = 0; __i < in->mounts_count; __i++) {
            chef_container_mount_destroy(&in->mounts[__i]);
        }
        free(in->mounts);
    }
}

#endif //! __CHEF_CREATE_PARAMETERS_DEFINED__

#ifndef __CHEF_USER_DESCRIPTOR_DEFINED__
#define __CHEF_USER_DESCRIPTOR_DEFINED__
struct chef_user_descriptor {
    char* username;
};


static void chef_user_descriptor_init(struct chef_user_descriptor* in) {
    memset(in, 0, sizeof(struct chef_user_descriptor));
}

static void chef_user_descriptor_copy(const struct chef_user_descriptor* in, struct chef_user_descriptor* out) {
    if (in->username != NULL) {
        out->username = strdup(in->username);
    } else {
        out->username = NULL;
    }
}

static void chef_user_descriptor_destroy(struct chef_user_descriptor* in) {
    if (in->username) {
        free(in->username);
    }
}

#endif //! __CHEF_USER_DESCRIPTOR_DEFINED__

#ifndef __CHEF_SPAWN_PARAMETERS_DEFINED__
#define __CHEF_SPAWN_PARAMETERS_DEFINED__
struct chef_spawn_parameters {
    char* container_id;
    struct chef_user_descriptor user;
    enum chef_spawn_options options;
    char* command;
    uint32_t environment_count;
    uint8_t* environment;
};


static void chef_spawn_parameters_init(struct chef_spawn_parameters* in) {
    memset(in, 0, sizeof(struct chef_spawn_parameters));
}

static void chef_spawn_parameters_copy(const struct chef_spawn_parameters* in, struct chef_spawn_parameters* out) {
    if (in->container_id != NULL) {
        out->container_id = strdup(in->container_id);
    } else {
        out->container_id = NULL;
    }
    chef_user_descriptor_copy(&in->user, &out->user);
    out->options = in->options;
    if (in->command != NULL) {
        out->command = strdup(in->command);
    } else {
        out->command = NULL;
    }
    out->environment_count = in->environment_count;
    if (in->environment_count) {
        out->environment = malloc(sizeof(uint8_t) * in->environment_count);
        assert(out->environment != NULL);
        memcpy(out->environment, in->environment, in->environment_count);
    } else {
        out->environment = NULL;
    }
}

static void chef_spawn_parameters_destroy(struct chef_spawn_parameters* in) {
    if (in->container_id) {
        free(in->container_id);
    }
    chef_user_descriptor_destroy(&in->user);
    if (in->command) {
        free(in->command);
    }
    if (in->environment) {
        free(in->environment);
    }
}

#endif //! __CHEF_SPAWN_PARAMETERS_DEFINED__

#ifndef __CHEF_FILE_PARAMETERS_DEFINED__
#define __CHEF_FILE_PARAMETERS_DEFINED__
struct chef_file_parameters {
    char* container_id;
    struct chef_user_descriptor user;
    char* source_path;
    char* destination_path;
};


static void chef_file_parameters_init(struct chef_file_parameters* in) {
    memset(in, 0, sizeof(struct chef_file_parameters));
}

static void chef_file_parameters_copy(const struct chef_file_parameters* in, struct chef_file_parameters* out) {
    if (in->container_id != NULL) {
        out->container_id = strdup(in->container_id);
    } else {
        out->container_id = NULL;
    }
    chef_user_descriptor_copy(&in->user, &out->user);
    if (in->source_path != NULL) {
        out->source_path = strdup(in->source_path);
    } else {
        out->source_path = NULL;
    }
    if (in->destination_path != NULL) {
        out->destination_path = strdup(in->destination_path);
    } else {
        out->destination_path = NULL;
    }
}

static void chef_file_parameters_destroy(struct chef_file_parameters* in) {
    if (in->container_id) {
        free(in->container_id);
    }
    chef_user_descriptor_destroy(&in->user);
    if (in->source_path) {
        free(in->source_path);
    }
    if (in->destination_path) {
        free(in->destination_path);
    }
}

#endif //! __CHEF_FILE_PARAMETERS_DEFINED__

#ifndef __GRACHT_CHEF_CONTAINER_MOUNT_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_CONTAINER_MOUNT_SERIALIZER_DEFINED__
static void serialize_chef_container_mount(gracht_buffer_t* buffer, const struct chef_container_mount* in) {
    serialize_string(buffer, in->host_path);
    serialize_string(buffer, in->container_path);
    serialize_int(buffer, (int)(in->options));
}

static void deserialize_chef_container_mount(gracht_buffer_t* buffer, struct chef_container_mount* out) {
    uint32_t _host_path_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->host_path = malloc(_host_path_length + 1);
    assert(out->host_path != NULL);
    deserialize_string_copy(buffer, &out->host_path[0], 0);
    uint32_t _container_path_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->container_path = malloc(_container_path_length + 1);
    assert(out->container_path != NULL);
    deserialize_string_copy(buffer, &out->container_path[0], 0);
    out->options = (enum chef_mount_options)deserialize_int(buffer);
}
#endif //! __GRACHT_CHEF_CONTAINER_MOUNT_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_CREATE_PARAMETERS_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_CREATE_PARAMETERS_SERIALIZER_DEFINED__
static void serialize_chef_create_parameters(gracht_buffer_t* buffer, const struct chef_create_parameters* in) {
    serialize_string(buffer, in->rootfs);
    serialize_int(buffer, (int)(in->type));
    serialize_uint32(buffer, in->mounts_count);
    for (uint32_t __i = 0; __i < in->mounts_count; __i++) {
        serialize_chef_container_mount(buffer, &in->mounts[__i]);
    }
}

static void deserialize_chef_create_parameters(gracht_buffer_t* buffer, struct chef_create_parameters* out) {
    uint32_t _rootfs_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->rootfs = malloc(_rootfs_length + 1);
    assert(out->rootfs != NULL);
    deserialize_string_copy(buffer, &out->rootfs[0], 0);
    out->type = (enum chef_rootfs_type)deserialize_int(buffer);
    out->mounts_count = deserialize_uint32(buffer);
    if (out->mounts_count) {
        out->mounts = malloc(sizeof(struct chef_container_mount) * out->mounts_count);
        assert(out->mounts != NULL);
        for (int __i = 0; __i < out->mounts_count; __i++) {
            deserialize_chef_container_mount(buffer, &out->mounts[__i]);
        }
    } else {
        out->mounts = NULL;
    }
}
#endif //! __GRACHT_CHEF_CREATE_PARAMETERS_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_USER_DESCRIPTOR_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_USER_DESCRIPTOR_SERIALIZER_DEFINED__
static void serialize_chef_user_descriptor(gracht_buffer_t* buffer, const struct chef_user_descriptor* in) {
    serialize_string(buffer, in->username);
}

static void deserialize_chef_user_descriptor(gracht_buffer_t* buffer, struct chef_user_descriptor* out) {
    uint32_t _username_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->username = malloc(_username_length + 1);
    assert(out->username != NULL);
    deserialize_string_copy(buffer, &out->username[0], 0);
}
#endif //! __GRACHT_CHEF_USER_DESCRIPTOR_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_SPAWN_PARAMETERS_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_SPAWN_PARAMETERS_SERIALIZER_DEFINED__
static void serialize_chef_spawn_parameters(gracht_buffer_t* buffer, const struct chef_spawn_parameters* in) {
    serialize_string(buffer, in->container_id);
    serialize_chef_user_descriptor(buffer, &in->user);
    serialize_int(buffer, (int)(in->options));
    serialize_string(buffer, in->command);
    serialize_uint32(buffer, in->environment_count);
    memcpy(&buffer->data[buffer->index], &in->environment[0], sizeof(uint8_t) * in->environment_count);
    buffer->index += sizeof(uint8_t) * in->environment_count;
}

static void deserialize_chef_spawn_parameters(gracht_buffer_t* buffer, struct chef_spawn_parameters* out) {
    uint32_t _container_id_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->container_id = malloc(_container_id_length + 1);
    assert(out->container_id != NULL);
    deserialize_string_copy(buffer, &out->container_id[0], 0);
    deserialize_chef_user_descriptor(buffer, &out->user);
    out->options = (enum chef_spawn_options)deserialize_int(buffer);
    uint32_t _command_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->command = malloc(_command_length + 1);
    assert(out->command != NULL);
    deserialize_string_copy(buffer, &out->command[0], 0);
    out->environment_count = deserialize_uint32(buffer);
    if (out->environment_count) {
        out->environment = malloc(sizeof(uint8_t) * out->environment_count);
        assert(out->environment != NULL);
        memcpy(&out->environment[0], &buffer->data[buffer->index], sizeof(uint8_t) * out->environment_count);
        buffer->index += sizeof(uint8_t) * out->environment_count;
    } else {
        out->environment = NULL;
    }
}
#endif //! __GRACHT_CHEF_SPAWN_PARAMETERS_SERIALIZER_DEFINED__

#ifndef __GRACHT_CHEF_FILE_PARAMETERS_SERIALIZER_DEFINED__
#define __GRACHT_CHEF_FILE_PARAMETERS_SERIALIZER_DEFINED__
static void serialize_chef_file_parameters(gracht_buffer_t* buffer, const struct chef_file_parameters* in) {
    serialize_string(buffer, in->container_id);
    serialize_chef_user_descriptor(buffer, &in->user);
    serialize_string(buffer, in->source_path);
    serialize_string(buffer, in->destination_path);
}

static void deserialize_chef_file_parameters(gracht_buffer_t* buffer, struct chef_file_parameters* out) {
    uint32_t _container_id_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->container_id = malloc(_container_id_length + 1);
    assert(out->container_id != NULL);
    deserialize_string_copy(buffer, &out->container_id[0], 0);
    deserialize_chef_user_descriptor(buffer, &out->user);
    uint32_t _source_path_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->source_path = malloc(_source_path_length + 1);
    assert(out->source_path != NULL);
    deserialize_string_copy(buffer, &out->source_path[0], 0);
    uint32_t _destination_path_length = *((uint32_t*)&buffer->data[buffer->index]);
    out->destination_path = malloc(_destination_path_length + 1);
    assert(out->destination_path != NULL);
    deserialize_string_copy(buffer, &out->destination_path[0], 0);
}
#endif //! __GRACHT_CHEF_FILE_PARAMETERS_SERIALIZER_DEFINED__

#endif //! __CHEF_CVD_SERVICE_H__
