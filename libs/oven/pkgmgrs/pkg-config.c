/**
 * Copyright 2024, Philip Meulengracht
 *
 * This program is free software : you can redistribute it and / or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation ? , either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 * 
 */

#include <chef/list.h>
#include <chef/platform.h>
#include <errno.h>
#include <libingredient.h>
#include <libpkgmgr.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <vlog.h>

// Files must be installed under the following dirs:
// /usr/share/pkgconfig/ (default, root=/)
// /chef/ingredients/%s/%s/pkgconfig/ (cc, root=/chef/ingredients/%s/%s/)

struct pkgconfig {
    struct pkgmngr base;
    char*          pcroot;
    char*          ccpcroot;
    char*          root;
    char*          ccroot;
    char*          target_platform;
    char*          target_architecture;
};

static const char* __get_root(struct pkgconfig* pkgconfig, struct ingredient* ingredient)
{
    if (strcmp(ingredient->package->platform, CHEF_PLATFORM_STR) ||
        strcmp(ingredient->package->arch, CHEF_ARCHITECTURE_STR)) {
        return pkgconfig->ccroot;
    }
    return pkgconfig->root;
}

static const char* __get_pcroot(struct pkgconfig* pkgconfig, struct ingredient* ingredient)
{
    if (strcmp(ingredient->package->platform, CHEF_PLATFORM_STR) ||
        strcmp(ingredient->package->arch, CHEF_ARCHITECTURE_STR)) {
        return pkgconfig->ccpcroot;
    }
    return pkgconfig->pcroot;
}

static const char* __get_pcroot2(struct pkgconfig* pkgconfig)
{
    if (strcmp(pkgconfig->target_platform, CHEF_PLATFORM_STR) ||
        strcmp(pkgconfig->target_architecture, CHEF_ARCHITECTURE_STR)) {
        return pkgconfig->ccpcroot;
    }
    return pkgconfig->pcroot;
}

static char* __string_array_join(const char* const* items, const char* prefix, const char* separator)
{
    char* buffer;
    
    if (items == NULL || *items == NULL) {
        return NULL;
    }

    buffer = calloc(4096, 1); 
    if (buffer == NULL) {
        return NULL;
    }

    for (int i = 0; items[i]; i++) {
        if (buffer[0] == 0) {
            strcpy(buffer, prefix);
        } else {
            strcat(buffer, separator);
            strcat(buffer, prefix);
        }
        strcat(buffer, items[i]);
    }
    return buffer;
}

static int __make_available(struct pkgmngr* pkgmngr, struct ingredient* ingredient)
{
    struct pkgconfig* pkgconfig = (struct pkgconfig*)pkgmngr;
    FILE* file;
    char  pcName[256];
    char* pcPath;
    int   written;
    int   status = 0;
    char* cflags;
    char* libs;

    if (ingredient->options == NULL) {
        // Can't add a pkg-config file if the ingredient didn't specify any
        // options for consumers.
        return 0;
    }

    // The package name specified on the pkg-config command line is defined 
    // to be the name of the metadata file, minus the .pc extension. Optionally
    // the version can be appended as name-1.0
    written = snprintf(&pcName[0], sizeof(pcName) - 1, "%s.pc", ingredient->package->package);
    if (written == (sizeof(pcName) - 1)) {
        errno = E2BIG;
        return -1;
    }
    
    pcPath = strpathcombine(__get_pcroot(pkgconfig, ingredient), &pcName[0]);
    if (pcPath == NULL) {
        return -1;
    }
    
    file = fopen(pcPath, "w");
    if(!file) {
        VLOG_ERROR("pkg-config", "__make_available: failed to open %s for writing: %s\n", pcPath, strerror(errno));
        free(pcPath);
        return -1;
    }

    cflags = __string_array_join((const char* const*)ingredient->options->inc_dirs, "-I{prefix}", " ");
    libs   = __string_array_join((const char* const*)ingredient->options->lib_dirs, "-L{prefix}", " ");
    if (cflags == NULL && libs == NULL) {
        goto cleanup;
    }

    fprintf(file, "# generated by chef, please do not manually modify this\n");
    fprintf(file, "prefix=%s\n", __get_root(pkgconfig, ingredient));

    fprintf(file, "Name: %s\n", ingredient->package->package);
    fprintf(file, "Description: %s by %s\n", ingredient->package->package, ingredient->package->publisher);
    fprintf(file, "Version: %i.%i.%i\n", ingredient->version->major, ingredient->version->minor, ingredient->version->patch);
    if (cflags != NULL) {
        fprintf(file, "Cflags: %s\n", cflags);
    }
    if (libs != NULL) {
        fprintf(file, "Libs: %s\n", libs);
    }

cleanup:
    free(pcPath);
    free(cflags);
    free(libs);
    fclose(file);
    return status;
}

static struct chef_keypair_item* __compose_keypair(const char* key, const char* value)
{
    struct chef_keypair_item* item = calloc(sizeof(struct chef_keypair_item), 1);
    if (item == NULL) {
        return NULL;
    }
    item->key = strdup(key);
    if (item->key == NULL) {
        free(item);
    }
    item->value = strdup(value);
    if (item->value == NULL) {
        free((void*)item->key);
        free(item);
    }
    return item;
}

static int __add_or_replace_pkgconfig_paths(struct pkgmngr* pkgmngr, struct list* environment)
{
    // Look and update/add the following language flags to account for
    // ingredient include paths
    struct pkgconfig* pkgconfig = (struct pkgconfig*)pkgmngr;
    struct list_item* item;
    struct {
        const char* ident;
        int         fixed;
    } idents[] = {
        { "PKG_CONFIG_PATH", 0 },
        { "PKG_CONFIG_LIBDIR", 0 },
        { NULL, 0 }
    };

    // Replace any environmental variable already provided by recipe
    list_foreach(environment, item) {
        struct chef_keypair_item* keypair = (struct chef_keypair_item*)item;
        for (int i = 0; idents[i].ident != NULL; i++) {
            if (!strcmp(keypair->key, idents[i].ident)) {
                const char* tmp = keypair->value;
                keypair->value = strdup(__get_pcroot2(pkgconfig));
                if (keypair->value == NULL) {
                    keypair->value = tmp;
                    return -1;
                }
                free((void*)tmp);
                idents[i].fixed = 1;
            }
        }
    }

    // Add any that was not provided
    for (int i = 0; idents[i].ident != NULL; i++) {
        if (!idents[i].fixed) {
            item = (struct list_item*)__compose_keypair(idents[i].ident, __get_pcroot2(pkgconfig));
            if (item == NULL) {
                return -1;
            }
            list_add(environment, item);
        }
    }
    return 0;
}

static void __destroy(struct pkgmngr* pkgmngr)
{
    struct pkgconfig* pkgconfig = (struct pkgconfig*)pkgmngr;
    if (pkgconfig == NULL) {
        return;
    }
    free(pkgconfig->root);
    free(pkgconfig->ccroot);
    free(pkgconfig->pcroot);
    free(pkgconfig->ccpcroot);
    free(pkgconfig->target_platform);
    free(pkgconfig->target_architecture);
    free(pkgconfig);
}

struct pkgmngr* pkgmngr_pkgconfig_new(struct pkgmngr_options* options)
{
    struct pkgconfig* pkgconfig;
    char              tmp[2048];
    int               status;
    VLOG_DEBUG("pkg-config", "pkgmngr_pkgconfig_new(root=%s)\n", options->root);

    pkgconfig = malloc(sizeof(struct pkgconfig));
    if (pkgconfig == NULL) {
        return NULL;
    }

    pkgconfig->base.make_available = __make_available;
    pkgconfig->base.add_overrides  = __add_or_replace_pkgconfig_paths;
    pkgconfig->base.destroy        = __destroy;

    // build roots
    pkgconfig->root = strdup("/");
    snprintf(&tmp[0], sizeof(tmp), "/chef/ingredients/%s/%s/", options->target_platform, options->target_architecture);
    pkgconfig->ccroot = strdup(&tmp[0]);

    // build pcroots
    snprintf(&tmp[0], sizeof(tmp), "%s/usr/share/pkgconfig/", options->root);
    pkgconfig->pcroot = strdup(&tmp[0]);
    snprintf(&tmp[0], sizeof(tmp), "%s/chef/ingredients/%s/%s/pkgconfig/", options->root, options->target_platform, options->target_architecture);
    pkgconfig->ccpcroot = strdup(&tmp[0]);

    // copy system info
    pkgconfig->target_platform = strdup(options->target_platform);
    pkgconfig->target_architecture = strdup(options->target_architecture);

    // ensure pc-roots exists
    VLOG_DEBUG("pkg-config", "pkgmngr_pkgconfig_new: creating %s\n", pkgconfig->pcroot);
    status = platform_mkdir(pkgconfig->pcroot);
    if (status && errno != EEXIST) {
        VLOG_ERROR("pkg-config", "failed to ensure that directory %s exists\n", pkgconfig->pcroot);
        __destroy(&pkgconfig->base);
        return NULL;
    }
    
    VLOG_DEBUG("pkg-config", "pkgmngr_pkgconfig_new: creating %s\n", pkgconfig->ccpcroot);
    status = platform_mkdir(pkgconfig->ccpcroot);
    if (status && errno != EEXIST) {
        VLOG_ERROR("pkg-config", "failed to ensure that directory %s exists\n", pkgconfig->ccpcroot);
        __destroy(&pkgconfig->base);
        return NULL;
    }
    return &pkgconfig->base;
}
